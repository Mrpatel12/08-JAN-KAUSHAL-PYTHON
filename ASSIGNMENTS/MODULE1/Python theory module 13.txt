                        MODULE - 1
                       INTRODUCTION TO PYTHON


Q1). Introduction to Python and its Features (simple, high-level, interpreted language).

Ans.

A). Python is a widely popular, general-purpose programming language renowned for its simplicity and readability,
    making it an excellent choice for beginners and experienced developers alike. 
   
B). The key features of the python language are as follows:

. Free and open source language

. Object oriented(OOP) language

. High-level performing language

. Interpreted language

. Dynamically typed language

. Highly Portable language


Q2). History and evolution of Python

Ans. 
    
History

A). The Python language was created by Guido Van Rossum at CWI in Netherlands in 1991.

B). Pyhton language was created because of untill the programming languages were not readable for the humans.

c). The Python was insprired by MONTY PYTHON's FLYING CIRCUS.

D). The first version of Python was released in February 1991 Pyhthon 0.9.0

Evolution

A). Python 1.0 (1994): First major release, adding functional programming tools.
B). Python 2.0 (2000): Introduced list comprehensions, garbage collection, and Unicode support (e.g., u"" strings). Python 2.7 was the final version in this series, supported until 2020.
C). Python 3.0 (2008): A major, backward-incompatible release fixing fundamental language issues, 
    making print a function and improving Unicode handling. 


Q3).Advantages of using Python over other programming languages.

Ans.

A). Presence of third-party modules: Python has a rich ecosystem of third-party modules and libraries that extend 
    its functionality for various tasks.

B). Extensive support libraries: Python boasts extensive support libraries like NumPy for numerical calculations 
    and Pandas for data analytics, making it suitable for scientific and data-related applications. 

C). Open source and large active community base: Python is open source, and it has a large and active community 
    that contributes to its development and provides support.

D). Versatile, easy to read, learn, and write: Python is known for its simplicity and readability, making it 
    an excellent choice for both beginners and experienced programmers.

E). Dynamically typed language: Python is dynamically typed, meaning you don't need to declare data types
    explicitly, making it flexible but still reliable.

F). Object-Oriented and Procedural programming language: Python supports both object-oriented and procedural 
    programming, providing versatility in coding styles.

G). Portable and interactive: Python is portable across operating systems and interactive,
    allowing real-time code execution and testing.


Q4). Installing Python and setting up the development environment (Anaconda, PyCharm, or VS Code)

Ans.

1.  Install Python

A). Most development environments include Python or make it easy to install, but you can also install it directly 
    from the source. 

B). Download and Install: Visit the official Python Downloads page and download the latest version for your 
    operating system.

C). During Installation (Windows): Be sure to check the box that says "Add Python to PATH" 
    (or "Add Python.exe to Path") on the first installer screen. 
    This makes it easier to use Python from your command line.

D). Verification: After installation, open your command prompt or terminal and type python
    --version (or python3 --version on some systems) and press Enter to verify the installation. 

2. Choose and Install a Development Environment 

   You can choose between managing environments with Anaconda, using a dedicated IDE
   like PyCharm, or using a flexible editor like VS Code. 

Option A: Anaconda (Data Science Focus):-
 
1). Anaconda is a distribution that simplifies package management and deployment, making it excellent
    for data science and machine learning. 

2). Download: Go to the Anaconda Distribution page and download the appropriate graphical installer.

3). Install: Run the installer and follow the prompts.

4). Launch: Open the Anaconda Navigator application. From here, you can launch Jupyter Notebooks,
    manage environments, and install VS Code or PyCharm.

5). Manage Environments: Use the "Environments" tab within Navigator or the conda command-line 
    utility to create isolated project spaces (e.g., conda create -n myprojectenv python=3.10). 


Option B: PyCharm (Dedicated Python IDE) 

    PyCharm is a powerful, feature-rich Integrated Development Environment (IDE) specifically designed for Python. 
    It is available in two editions: the free Community Edition and the paid Professional Edition. 

1). Download: Visit the JetBrains PyCharm Download page and select either the Community or Professional installer
    for your OS.

2). Install: Run the installer and follow the standard installation prompts.

3). Configuration: The first time you open PyCharm, it will walk you through initial settings.
    To set up an interpreter for a new project, go to File > Settings > Project > Python Interpreter.
    Here you can select a previously installed Python version or a Conda environment. 


Option C: VS Code (Lightweight and Versatile)

    Visual Studio Code is a popular, free, open-source code editor that can be extended with plugins 
    to handle almost any programming language, including Python. 

1). Download: Download and install VS Code from the official website.

2). Install Python Extension: Open VS Code, navigate to the Extensions view 
    (Ctrl+Shift+X or click the Extensions icon), search for "Python" by Microsoft, and install it.
    This provides debugging, linting, code completion, and environment management features.

3). Select Interpreter: Open your project folder. Use the command palette (Ctrl+Shift+P) and type 
    "Python: Select Interpreter" to choose the Python installation or Conda environment you want to use for
    your current project. 
 

3.  Verification

    Once your environment is set up, create a new file named hello.py and add the following line: 

    print("Hello, Python environment is set up!")
    
    Run this script using the run button within your IDE/Editor (PyCharm or VS Code) or from your 
    terminal/command prompt using the command python hello.py to confirm everything is working correctly.


Q5). Writing and executing your first Python program

Ans.

Step 1: Install Python

    First, ensure Python is installed on your computer. 

    Visit the official Python website to download the latest version for your operating system
    (Windows, macOS, or Linux).

    Run the installer.

    Crucial for Windows: During installation, check the box that says "Add Python to PATH" to make it easier
    to run Python from the command line.

    Verify the installation by opening your terminal or Command Prompt and typing python --version 
    (or python3 --version on some systems). You should see the installed Python version displayed. 
 

Step 2: Write the Program

    You can use any basic text editor (like Notepad, TextEdit, or a more advanced code editor like VS Code or
    PyCharm). 

    Open your text editor.

    Type the following code:

    python
    print("Hello, World!")

    This single line is a function call that tells Python to display the text "Hello, World!" on the screen. 
   
    Save the file with a .py extension, for example, hello.py. Remember where you saved the file 
    (e.g., your Desktop or a dedicated PythonPrograms folder). 


Step 3: Execute the Program

    Open your terminal (Command Prompt on Windows, Terminal on macOS/Linux) to run your program. 

    Navigate to the directory where you saved your file using the cd command (change directory). 
    For example, if you saved it to your Desktop, you would type:

    bash

    cd Desktop

    Run the program by typing python followed by the filename:

    bash

    python hello.py

    (You might need to use python3 hello.py depending on your system configuration).
    View the output: The message Hello, World! should appear in your terminal.

Q6). Understanding Python’s PEP 8 guidelines.

Ans. 
     PEP 8 is the official style guide for Python code that provides conventions to promote consistency and enhanced readability. Adhering to it makes code easier to read, maintain, and collaborate on with other developers. 
     Key guidelines from PEP 8 include:

     Indentation: Use 4 spaces per indentation level and avoid tabs.

     Maximum Line Length: Limit lines to a maximum of 79 characters, using implicit line continuation for long 
     lines. 

     Blank Lines: Use two blank lines around top-level function/class definitions, one blank line between 
     methods in a class, and sparingly inside functions.

     Whitespace: Avoid extra whitespace inside parentheses, brackets, or braces, and immediately before commas, 
     semicolons, or colons. Use a single space after commas, semicolons, and colons, and around binary operators.

     Naming Conventions: Use snake_case for functions and variables, CapitalizedWords for classes, and 
     UPPER_CASE_WITH_UNDERSCORES for constants. Avoid using single-character names that can be confused 
     with numbers.

     Comments and Docstrings: Explain the "why" in comments, not just the "what". Indent block comments and 
     start with # and a space. Write docstrings for public modules, functions, classes, and methods,
     following PEP 257.

     Imports: Place imports at the top of the file, on separate lines. Group standard library,
     related third-party, and local application imports with blank lines between groups. Avoid wildcard imports.


Q7).Indentation, comments, and naming conventions in Python

Ans.

    Indentation is fundamental to Python's syntax; it defines the structure and scope of code blocks
    (e.g., inside functions, loops, and conditional statements) where other languages might use braces {}.
 
    Mandatory Use: Python will raise an IndentationError if indentation is missing or inconsistent within 
    the same block.

    Standard Practice: The official PEP 8 style guide recommends using four spaces per indentation level.
    Consistency: Avoid mixing tabs and spaces, as this can lead to hard-to-detect errors in Python 3.


Q8).Writing readable and maintainable code

Ans.

    Writing readable and maintainable code is about crafting software that is easy for humans to understand,
    modify, and extend, rather than just code that works for the computer. It is essential for reducing 
    technical debt, facilitating collaboration, and ensuring the longevity of projects. 

    Here is a guide to best practices based on clean code principles:

    1. Meaningful Naming:-
  
       Be Descriptive: Use names that reveal intent, such as calculateTotalAmount() instead of calc() or doStuff().
       Use Pronounceable/Searchable Names: Avoid single-letter variables (like i, x) except for very short-lived 
       loops.

       Follow Conventions: Use consistent conventions (e.g., camelCase for JavaScript, snake_case for Python).
       Use Plurals: Use plural names for collections or arrays (e.g., users instead of userList).
 
    2. Function Design:-

       Keep Them Small: Functions should do one thing and do it well (Single Responsibility Principle). 
       Aim for 5-20 lines per function.

       Limit Parameters: Functions with many parameters are hard to test and read. Consider passing an object
       or using a builder pattern if more than 3-4 arguments are needed.

       Avoid Nested Code: Deeply nested if or for loops are hard to read. Use "early returns" (guard clauses) 
       to flatten your code. 

       3. Maintainability (DRY and Simplicity):-

       DRY Principle (Don't Repeat Yourself): Avoid code duplication. If the same logic appears in multiple places,
       extract it into a function or class.

       KISS Principle (Keep It Simple, Stupid): Avoid unnecessary complexity. If a simpler solution exists, use it.

       Avoid Magic Numbers/Strings: Replace raw numbers or strings with named constants 
       (e.g., MAX_RETRY_COUNT = 5 instead of just using 5).

       Refactor Regularly: Clean up code as you go rather than waiting for a massive "refactor phase". 

       4. Code Structure and Style:-

        Consistent Formatting: Use a consistent style for indentation, spacing, and line breaks. 
        Use automated tools like ESLint, Prettier, or Black (Python) to enforce this.

        Use Whitespace Effectively: Separate logical sections of code with blank lines, similar to paragraphs 
        in a book.

        Use Modern Features: Use modern language syntax (e.g., arrow functions, template literals) 
        that can reduce boilerplate. 

        5. Comments and Documentation:-

        Code Should Be Self-Explanatory: If you feel the need to add a comment to explain what the code does,
        try to refactor the code to make it clearer instead.

        Comment "Why," Not "What": Use comments to explain the reasons behind a decision, especially if it handles
        a complex edge case.

        Use TODOs: Mark areas that need future work with // TODO or // FIXME. 

        6. Testing:-
 
        Write Tests: Well-tested code is easier to maintain because you can change it without fear of breaking 
        existing functionality.
 
        TDD (Test-Driven Development): If possible, write tests before writing the actual code to define
        expected behavior. 

        Summary Checklist for Readable Code


        Practice 	       Description

        Naming	             Does the name tell me what the variable/function does?
        Size	             Is the function short and focused on one task?
        Comment              Do they explain why, not what?
        Formatting           Is it consistent with the rest of the project?
        Duplication	     Did I copy-paste this logic? (If yes, refactor).

        By following these practices, you ensure that your code is not just a temporary solution,
        but a durable asset that is easy to manage over time.   

Q9).Understanding data types: integers, floats, strings, lists, tuples, dictionaries, sets.

Ans.

       Integers (int): Represent whole numbers, both positive and negative, without a decimal point. 
       Examples include 1, -10, and 1000.

       Floats (float): Represent real numbers (or floating-point numbers) that have a decimal point. 
       Examples include 3.14, -0.001, and 2.0.

       Strings (str): Represent sequences of characters and are used for storing text. 
       They are enclosed in single quotes ('hello'), double quotes ("world"), or triple quotes for multi-line text.

       Lists (list): Ordered collections of items. Lists are mutable, meaning their elements can be changed after
       creation. They are defined using square brackets: [1, "apple", 3.14].

       Tuples (tuple): Ordered collections of items, similar to lists, but they are immutable, meaning their
       elements cannot be changed after creation. They are defined using parentheses: (1, "apple", 3.14).

       Dictionaries (dict): Unordered collections of data in key-value pairs. They are used to store data
       logically as a key that maps to a value, allowing for efficient data retrieval. 
       They are defined using curly braces: {"name": "John", "age": 30}.

       Sets (set): Unordered collections of unique items. They are useful for quickly checking membership and 
       removing duplicate entries. They are defined using curly braces (or the set() constructor): {1, 2, 3}. 


Q10).Python variables and memory allocation.


Ans).
 
      In Python, variables are not memory containers themselves but labels or references pointing to objects
      stored in a private heap memory.

      Memory allocation and deallocation are handled automatically by the Python Memory Manager
      and an automatic garbage collection system, abstracting low-level memory details from the programmer. 


Q11).Python operators: arithmetic, comparison, logical, bitwise.

Ans.

      Python operators are special symbols used to perform operations on variables and values. They are categorized into several groups, including arithmetic, comparison, logical, and bitwise operators. 


      Arithmetic Operators:-
      These operators are used to perform common mathematical operations. 

      + Addition: Adds two operands (e.g., x + y).
      - Subtraction: Subtracts the right operand from the left (e.g., x - y).
      * Multiplication: Multiplies two operands (e.g., x * y).
      / Division: Divides the left operand by the right, resulting in a float (e.g., x / y).
      % Modulus: Returns the remainder of the division (e.g., x % y).
      ** Exponentiation: Raises the left operand to the power of the right operand (e.g., x ** y). 

       Comparison Operators:-
       These operators compare the values of two operands and return a boolean result (True or False). 

       == Equal: Returns True if both operands are equal (e.g., x == y).
       != Not equal: Returns True if both operands are not equal (e.g., x != y).
       > Greater than: Returns True if the left operand is greater than the right (e.g., x > y).
       < Less than: Returns True if the left operand is less than the right (e.g., x < y).
       >= Greater than or equal to: Returns True if the left operand is greater than or equal to the right (e.g., x >= y).
       <= Less than or equal to: Returns True if the left operand is less than or equal to the right (e.g., x <= y). 

      Logical Operators:-
      These operators are used to combine conditional statements and evaluate expressions to make decisions. 
      
      and: Returns True if both statements are true (e.g., x < 5 and x < 10).
      or: Returns True if one of the statements is true (e.g., x < 5 or x < 4).
      not: Reverses the result, returning False if the result is true (e.g., not(x < 5 and x < 10)). 

      Bitwise Operators:-
      Bitwise operators perform operations on integer operands by treating them as sequences of binary bits. 
  
      & AND: Sets each bit to 1 if both bits are 1, otherwise 0.
      OR: Sets each bit to 1 if at least one of the bits is 1, otherwise 0.
      ^ XOR: Sets each bit to 1 if only one of the bits is 1, otherwise 0.
      ~ NOT: Inverts all the bits (one's complement).
      << Left shift: Shifts the bits to the left, pushing zeros in from the right.
      >> Right shift: Shifts the bits to the right, pushing copies of the leftmost bit in from the left
     (for positive numbers, pushes zeros). 


Q11).Introduction to conditionalstatements: if, else, elif.

Ans.

       Conditional statements are fundamental programming constructs that allow a program to make decisions and 
       control its flow based on whether certain conditions are True or False. 

       The primary statements used for this purpose in many programming languages are if, else, and elif 
       (short for "else if"). 

        

       The if Statement:-

       The if statement is the most basic form of a conditional. It checks if a condition is true and, 
       if so, executes the code block indented beneath it [1]. 

       Syntax (Python example):
       
       python

       if condition:
       # code to execute if condition is true
       Example:
       
       python
       age = 20
       if age >= 18:
       print("You are old enough to vote.")

       
       The else Statement:-
 
       The else statement is used in conjunction with an if statement to provide an alternative 
       block of code to run when the if condition evaluates to false [1]. The else block will execute only if
       the if condition is not met. 
     
       Syntax:
     
       python
       if condition:
       # code to execute if condition is true
       else:
       # code to execute if condition is false

       Example:
       python
       age = 16
       if age >= 18:
       print("You are old enough to vote.")
       else:
       print("You are not old enough to vote yet.")

 
       The elif Statement:-

       The elif (short for "else if") statement allows you to check multiple conditions sequentially [1]. 
       If the preceding if condition is false, the program checks the next elif condition. 
       You can have any number of elif blocks between the initial if and an optional final else block. 


       Syntax:

       python
       if condition1:
       # code for condition1
       elif condition2:
       # code for condition2
       elif condition3:
       # code for condition3
       else:
       # code if none of the above are true

       Example:
       python
       score = 85

       if score >= 90:

       print("Grade: A")

       elif score >= 80:

       print("Grade: B")

       elif score >= 70:

       print("Grade: C")

       else:

       print("Grade: D or F")


Q12). Nested if-else condition

Ans.
      Nested if else statements allow for more complex decision-making within the program. 
      You can nest if else statements with other if else statements, creating conditions at multiple levels.

      Syntax of Nested If Else Statement:
      if (condition1) {
      // Code block for condition1 being true
      if (condition2) {
      // Code block for condition1 and condition2 both being true}

      else 
      {
      // Code block for condition1 being true and condition2 being false
      }
    }

     else
     {
     // Code block for condition1 being false  
     }


Q13).Introduction to for and while loops.

Ans.

      A).For Loops (Definite Iteration):-

     .Purpose: Best used when the number of iterations is known in advance.

     .Function: Iterates over a sequence (list, string, range).
    
     .Example (Python): for i in range(5): print(i) prints 0-4.
     
     .Key Characteristic: Automates the initialization, condition check, and increment/decrement. 
 
     B).While Loops (Indefinite Iteration):-

      .Purpose: Used when the number of iterations is not known, or when waiting for a specific event/condition.

      .Function: Continues as long as the condition is true.

      .Example (Python): while i < 5: print(i); i += 1.

      .Key Characteristic: Requires careful management of the condition to avoid "infinite loops". 


Q14).How loops work in Python

Ans.

      for loops are used when you have a block of code which you want to repeat a fixed number of times. 
      The for-loop is always used in combination with an iterable object, like a list or a range. 
      The Python for statement iterates over the members of a sequence in order, executing the block each time. 
      Contrast the for statement with the ''while'' loop, used when a condition needs to be checked each iteration
      or to repeat a block of code forever.

      For example:

      For loop from 0 to 2, therefore running 3 times.


      for x in range(0, 3):
            print("We're on time %d" % (x))
      While loop from 1 to infinity, therefore running forever.


      x = 1
       while True:
           print("To infinity and beyond! We're getting close, on %d now!" % (x))
        x += 1

        When running the above example, you can stop the program by pressing ctrl+c at the same time. 
        As you can see, these loop constructs serve different purposes. The for loop runs for a fixed amount 
        of times, while the while loop runs until the loop condition changes. In this example, the condition
        is the boolean True which will never change, so it will run forever.


Q15).Using loops with collections (lists, tuples, etc.)

Ans.

      In Python, you can efficiently iterate over collections such as lists and tuples using for loops,
      which are the standard and most readable method. The while loop can also be used, but the for loop 
      is generally preferred. 

      Using a for Loop (Recommended):-

      The basic syntax for a for loop is for variable in sequence:, where the variable temporarily holds each
      item in the collection during each iteration of the loop. This approach automatically handles the 
      iteration and termination of the loop. 

      Iterating over elements directly: This is the most common and simple way to loop through items.
    
      python

      # Looping through a list

      fruits_list = ["apple", "banana", "cherry"]
      for fruit in fruits_list:
      print(f"I like {fruit}")

      # Looping through a tuple

        coordinates_tuple = (10, 20, 30)
        for coord in coordinates_tuple:
        print(f"Coordinate: {coord}")
        Iterating with index using enumerate(): If you need both the index and the value of each item, 
        the built-in enumerate() function is the most efficient way.

        python

        fruits_list = ["apple", "banana", "cherry"]
        for index, fruit in enumerate(fruits_list):
        print(f"Index {index}: {fruit}")
 
        Using a while Loop:-

        While for loops are better for iterating over a known sequence, while loops can also be used, 
        especially if you need more control over the iteration process. This requires manually managing an index
        variable. 
   
        python

        fruits_list = ["apple", "banana", "cherry"]
        i = 0
        while i < len(fruits_list):
        print(fruits_list[i])
        i += 1


Q16).Understanding how generators work in Python

Ans.

        Python generators are functions or expressions that produce a sequence of values one at a time, 
        on demand (lazy evaluation), without storing the entire sequence in memory. This makes them highly
        memory-efficient for large or infinite datasets. 

        How Generators Work:-
  
       1. A generator functions similar to a regular function but uses the yield keyword instead of return. 

       2. Calling the Function: When a generator function is called, it does not execute the code immediately. 
          Instead, it returns a generator object.

       3. Pausing Execution: Execution starts only when a value is requested from the generator object, 
          typically via a for loop or the next() function. The function runs until it hits a yield statement.

       4. Yielding Value and Preserving State: At the yield statement, the function pauses, returns the value 
          to the caller, and crucially, saves its entire local state (local variables, instruction pointer, etc.).

       5. Resuming Execution: When next() is called again, the function resumes exactly from where it left off 
          with the preserved state, continuing until the next yield.

       6. Stopping Iteration: This cycle continues until the function ends or encounters a return statement
          with no value. At that point, Python automatically raises a StopIteration exception, 
          which signals to the for loop (or next() caller) that the sequence is complete. 

          Example: A Simple Generator:-
 
          Consider a function to generate a sequence of numbers:

python
def count_up_to(limit):
    num = 1
    while num <= limit:
        yield num  # Pauses and returns the current 'num'
        num += 1   # Resumes here when 'next()' is called

         When you call count_up_to(3), a generator object is created.

         The first call to next() runs the code until yield num (where num is 1), returns 1, and pauses.

         The second next() call increments num to 2, runs to yield num, returns 2, and pauses.

         The third next() call increments num to 3, runs to yield num, returns 3, and pauses.

         The fourth next() call increments num to 4, the while condition becomes false, and the function ends, 
         raising StopIteration. 

         Ways to Create Generators:-

         Generators can be created in two primary ways:
         
         Generator Functions: Defined using def and the yield keyword, as shown in the example above. 
         They are ideal for complex logic or large code blocks.
 
         Generator Expressions: A concise, single-line way to create generators, similar to list comprehensions
         but using parentheses () instead of square brackets [].

         python
 
         squares = (x * x for x in range(10))
 
         Key Benefits
         
         1. Memory Efficiency: They process data in chunks, using minimal memory at any given time,
            which is crucial for handling large files or datasets that wouldn't fit in memory otherwise.

         2. Lazy Evaluation: Values are computed only when needed, which can save computational time if not 
            all values in a sequence are required.

         3. Infinite Sequences: Since values are generated on demand, you can define generators for infinite
            data streams (e.g., all prime numbers, Fibonacci sequence) that would be impossible to store in a list.

         4. Simplified Code: They offer a much cleaner and more readable way to create iterators compared to 
            writing a custom class with __iter__() and __next__() methods. 


Q17).Difference between yield and return

Ans.

	YIELD	                                                RETURN

1.  Yield is generally used to convert a                  Return is generally used for the end of the execution and “returns” 
    regular Python function into a generator.             the result to the caller statement.
	
2.  It replace the return of a function to                It exits from a function and handing back a value 
    suspend its execution without destroying              to its caller.
    local variables.                                       
    	                              
3.  It is used when the generator returns                 It is used when a function is ready to send a value.
    an intermediate result to the caller.	

4.  Code written after yield statement                    while, code written after return statement wont 
    execute in next function call.	                  execute.
    
5.  It can run multiple times.	                          It only runs single time.

6.  Yield statement function is executed                  Every function calls run the function from the start.
    from the last state from where the 
    function get paused.	



Q18).Understanding iterators and creating custom iterators.


Ans.

       Understanding Iterators and Iterables:-

       Iterable: An object that can return an iterator (e.g., lists, tuples, dictionaries, sets) using iter().

       Iterator: The object that actually performs the iteration, remembering its position, and is traversed 
                 using next().

       Protocol: Iterators must implement __iter__() (returns the object itself) and __next__() 
                 (returns the next item). 

       Creating Custom Iterators:-

      To create a custom iterator, you must:

      Define a class with __init__() to manage state (e.g., a counter).
 
      Implement __iter__() to return the object itself (return self).

      Implement __next__() to return values or raise StopIteration. 


       Custom Iteration Alternatives:-

      Generators: A simpler way to create iterators using functions and the yield keyword,
                  which automatically handles __next__ and StopIteration.

       for loops: Automatically handle the iter() and next() calls, making them the standard way to consume 
                  iterators. 


Q19).Defining and calling functions in Python

Ans.

      Defining a Function:-

      We can define a function in Python, using the def keyword. A function might take input in the form 
      of parameters.

      The syntax to declare a function is:
     
      def function_name(parameters):
         #STATEMENT
      return expression

      Calling a Function:-

      After creating a function in Python we can call it by using the name of the functions followed by 
      parenthesis containing parameters of that particular function.

      def fun():
         print("Welcome to GFG")
    
      fun() # Driver code to call a function


Q20).Function arguments (positional, keyword, default).


Ans).

      Positional Arguments:-

      Positional arguments are values passed to a function based on their order or position in the function call. 
      The first argument in the call is assigned to the first parameter in the function definition, 
      the second argument to the second parameter, and so on. 

      Order matters: Changing the order of positional arguments can change the function's behavior or result 
      in an error if types are mismatched.

      Mandatory: Unless a default value is provided, all positional parameters must receive a value during 
      the function call. 

      python

def subtract(a, b):
    return a - b

      result = subtract(10, 5) # 10 is assigned to 'a', 5 to 'b'
 
      # Output: 5
        result_wrong_order = subtract(5, 10) # 5 is assigned to 'a', 10 to 'b'
     # Output: -5 (result changes)


       Keyword Arguments:-

       Keyword arguments allow you to pass values by explicitly naming the parameter they correspond to in the 
       function call using the name=value syntax. 

       Order does not matter: Because arguments are matched by name, their position in the function call is 
       flexible.

       Readability: This method enhances code readability, especially for functions with many parameters. 

       python

       def student_details(name, age):
       print(f"Student: {name}, Age: {age}")

      # Order is different from definition, but works because of keywords
   
        student_details(age=21, name="Rahul")
      # Output: Student: Rahul, Age: 21


        Default Arguments:-
 
        Default arguments are parameters with predefined values in the function definition. If a value for a 
        default argument is not provided during the function call, the default value is used. 

        Optional: These arguments become optional when calling the function.

        Overridable: If a value is provided, it overrides the default.
 
        Placement rule: In the function definition, default arguments must follow any non-default (positional)
        arguments to avoid a SyntaxError. 
 
        python

        def greet(name, greeting="Hello"):
          print(f"{greeting}, {name}!")

        greet("Sita")
         # Output: Hello, Sita! (uses default greeting)

        greet("Ravi", "Hi")
         # Output: Hi, Ravi! (overrides default greeting)


Q21).Scope of variables in Python.

Ans).

      In Python, variables play a key role in storing and managing data. Their behavior and accessibility 
      depend on where they are defined in the program. In this article, we’ll explore global and local variables,
      how they work and common scenarios with examples.


      Local Variables:-
 
      Local variables are created inside a function and exist only during its execution. They cannot be accessed
      from outside the function.

      Example 1: In this code, we are creating and accessing a local variable inside a function.


def greet():
    msg = "Hello from inside the function!"
    print(msg)
​
greet()


      Global Variables:-

      Global variables are declared outside all functions and can be accessed anywhere in the program, 
      including inside functions.

      In this example, we are creating a global variable and then accessing it both inside and outside a function.

msg = "Python is awesome!"
​
def display():
    print("Inside function:", msg)
​
display()
print("Outside function:", msg)


Q22).Built-in methods for strings, lists, etc.

Ans).
  
      String Methods:-

      Strings are immutable, so methods return a new string with the modification. 

      upper(): Converts all characters to uppercase.

      lower(): Converts all characters to lowercase.

      strip(): Removes leading and trailing whitespace.

      split(): Splits the string into a list of substrings based on a specified delimiter (whitespace by default).
      
      join(): Concatenates elements of an iterable into a single string using the string as a separator.

      find(): Searches for a specified value and returns the index of the first occurrence (or -1 if not found).
              replace(old, new): Replaces occurrences of a specified substring with another.
              startswith() / endswith(): Checks if the string starts or ends with a specified value,
              returning True or False. 


      You can find more in the Python String Methods documentation. 

      List Methods:-

      Lists are mutable, meaning most methods modify the list in-place. 

      append(item): Adds an item to the end of the list.

      insert(index, item): Inserts an item at a specified position.

      remove(item): Removes the first occurrence of a specified item.
      
      pop(index): Removes and returns the item at a specified position (or the last item if index is not specified).

      sort(): Sorts the list in ascending order in-place.
  
      reverse(): Reverses the order of elements in-place.
 
      count(item): Returns the number of times a specified item appears. 


Q23).Understanding the role of break, continue, and pass in Python loops.

Ans).

       In Python, break, continue, and pass statements alter the flow of a loop's execution: 
       
       break terminates the loop entirely.
      
       continue skips the current iteration and proceeds to the next one.
      
       pass is a null operation; nothing happens when it executes. 

       The break Statement:-
 
       The break statement is used to exit a for or while loop prematurely, even if the loop condition has not
       been met or the iterations have not been exhausted [1]. 
   
       Example:
       This loop will stop immediately once i is equal to 3.
  
     for i in range(5):
    if i == 3:
        break
    print(i)

# Output:
# 0
# 1
# 2


       The continue Statement:-

       The continue statement causes the rest of the current block of code within the loop to be skipped, 
       and the control flow goes immediately to the next iteration of the loop [1]. 
       
       Example:

       This loop will skip printing the number 3, but continue the loop for other numbers.

for i in range(5):
    if i == 3:
        continue
    print(i)

# Output:
# 0
# 1
# 2
# 4
 
        The pass Statement:-

        The pass statement is a null operation; nothing happens when it executes [1]. It is primarily used as a placeholder where syntax requires a statement, but you have no code to execute, such as in an empty loop, function, class, or if block [1]. 

        Example:

        This loop runs without error, but performs no action when i is 3. 


for i in range(5):
    if i == 3:
        pass
    print(i)

# Output:
# 0
# 1
# 2
# 3
# 4


Q24).Understanding how to access and manipulate strings.

Ans).

     Strings are ordered sequences of characters accessed via 0-based indexing (e.g., s[0]) or negative indexing
     for positions from the end, often using []. They are immutable, meaning manipulations like slicing,
     concatenation (+), or methods (e.g., .upper(), .split()) create new strings rather than changing the 
     original. 

     Accessing and Slicing Strings:-

     Indexing: Individual characters are retrieved using square brackets []. str[0] is the first character; 
     str[-1] is the last.

     Slicing: Extracts a substring using [start:stop:step]. Example: s[0:4] gets characters from index 0 up to, 
     but not including, 4.

     Length: Use len(string) (Python) or .length (JavaScript/Java) to find the number of characters. 


      Common String Manipulations:-

      Concatenation: Joining strings using + (e.g., new_str = "Hello" + " " + "World").

      Case Conversion: .upper(), .lower().

      Whitespace Removal: .strip(), .trim().

      Searching: .find() or .index() to locate substrings.

      Replacement: .replace(old, new).

      Splitting: .split(delimiter) converts a string into a list/array. 


Q25).How functional programming works in Python.

Ans).

      Pure Functions: Functions in FP should ideally be pure. A pure function has two main properties:
               
      It always produces the same output for the same input arguments.

      It has no side effects (e.g., modifying global variables, I/O operations, or changing mutable input data 
      in place).

      Immutability: FP encourages the use of immutable data structures, which cannot be changed after creation. 
      Python provides several built-in immutable types such as int, float, str, and tuple.

      Functions as First-Class Citizens: In Python, functions are treated as objects. This means you can assign 
      functions to variables, pass them as arguments to other functions, and return them as results from 
      functions. This is a foundational aspect that makes FP possible in Python.

       Higher-Order Functions: These are functions that take one or more functions as arguments or return a 
       function as a result. Python's built-in map(), filter(), and sorted() are examples of higher-order 
       functions.
      
       Recursion: In pure functional programming, iteration is achieved through recursion 
       (a function calling itself) rather than loops. Python supports recursion, though it should be used with a
       base case to avoid infinite loops. 


Q26).Using map(), reduce(), and filter() functions for processing data.

Ans.

        Map Function in Python:-
        map() function returns a map object(which is an iterator) of the results after applying the given
        function to each item of a given iterable (list, tuple, etc.).

        Syntax:

        map(fun, iter)

        Parameters:

        fun: It is a function to which map passes each element of given iterable.
        
        iter: iterable object to be mapped.

        Example: The following code doubles each element in a list using map().

def double(n):
    return n * 2
​
n = [5, 6, 7, 8]
res = map(double, n)
print(list(res))


        Reduce Function in Python:-

        The reduce function is used to apply a particular function passed in its argument to all of the list
        elements mentioned in the sequence passed along.This function is defined in "functools" module.

        Syntax:

        reduce(func, iterable[, initial])

        Parameters:

        fun: It is a function to execute on each element of the iterable object.

        iter: It is iterable to be reduced 

        initial (optional): Initial value for the accumulator.

        Example: The following code calculates the product of all elements in a list using reduce().

        import functools
​
        n = [1, 2, 3, 4]
​
        prod = functools.reduce(lambda x, y: x * y, n)
        
        print(prod)

        
        Filter Function in Python:-

        The filter() method filters the given sequence with the help of a function that tests each element in 
        the sequence to be true or not.

        Syntax: 

        filter(function, sequence)

        Parameters:

        function: function that tests if each element of a sequence is true or not.

        sequence: sequence which needs to be filtered, it can be sets, lists, tuples, or containers of any
                  iterators.

        Example: The following code filters out even numbers from a list using filter().

def is_even(n):
    return n % 2 == 0
​
n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
​
en = filter(is_even, n)
print(list(en))



Q27).Introduction to closures and decorators.

Ans.

      Closures in Detail:-
   
      A function object that "closes over" variables in its scope, allowing them to persist.
 
      Key Requirements:

      Must be a nested function (a function inside a function).

      The inner function must reference a value in the enclosing scope.
 
      The enclosing function must return the inner function.

      Purpose: Data encapsulation (hiding), avoiding global scope, and creating function factories. 

      Example of a Closure:

python
def outer_func(msg):
    def inner_func():
        print(msg) # 'msg' is remembered from the outer scope
    return inner_func

hi_func = outer_func("Hello")
hi_func() # Outputs: Hello


       Decorators in Detail:-

       A design pattern that wraps a function, method, or class to modify its behavior without altering its source code.

      Syntax: 
          They use the @decorator_name syntax (pie syntax) placed above the function definition.

       How they work: 
          The @ symbol is syntactic sugar for function = decorator(function). 
 
       Example of a Decorator:
 
        python

def my_decorator(func):
    def wrapper():
        print("Before function call.")
        func()
        print("After function call.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Output:
# Before function call.
# Hello!
# After function call.




